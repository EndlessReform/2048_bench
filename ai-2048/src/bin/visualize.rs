use ai_2048::engine as GameEngine;
use ai_2048::engine::{get_tile_val, Board, Move};
use ai_2048::{trace, serialization};
use clap::Parser;
use std::path::PathBuf;
use owo_colors::{OwoColorize, colors::*};

#[derive(Debug, Parser)]
#[command(name = "visualize", about = "Visualize a 2048 run trace (.a2run or .a2run2)")]
struct Args {
    /// Path to a .a2run/.a2run2 file generated by the parallel runner
    path: PathBuf,
    /// Optional step index to display (0..=highest). Defaults to highest.
    #[arg(long, short = 's')]
    step: Option<usize>,
}

fn main() -> anyhow::Result<()> {
    let args = Args::parse();
    GameEngine::new();
    // Dispatch by extension; default to v1 if unknown
    let ext = args.path.extension().and_then(|s| s.to_str()).unwrap_or("");
    let (steps, elapsed, mps, max_score, highest_tile, board_to_show, chosen_step, clamped, next_move) =
        if ext == "a2run2" {
            let run = serialization::read_postcard_from_path(&args.path)?;
            let steps = run.meta.steps as usize;
            let elapsed = run.meta.elapsed_s as f64;
            let mps = if elapsed > 0.0 { (steps as f64) / elapsed } else { 0.0 };
            // Determine which step to show: default to highest (final), clamp if necessary
            let requested = args.step.unwrap_or(steps);
            let (chosen_step, clamped) = if requested > steps { (steps, true) } else { (requested, false) };
            let raw_board = if chosen_step < steps {
                run.steps
                    .get(chosen_step)
                    .map(|s| s.pre_board)
                    .unwrap_or(run.final_board)
            } else {
                run.final_board
            };
            let board_to_show = Board::from_raw(raw_board);
            let next_move = if chosen_step < steps {
                run.steps.get(chosen_step).map(|s| s.chosen)
            } else { None };
            (
                steps,
                elapsed,
                mps,
                run.meta.max_score,
                run.meta.highest_tile,
                board_to_show,
                chosen_step,
                clamped,
                next_move,
            )
        } else {
            let run = trace::parse_run_file(&args.path)?;
            let steps = run.meta.steps as usize;
            let elapsed = run.meta.elapsed_s as f64;
            let mps = if elapsed > 0.0 { (steps as f64) / elapsed } else { 0.0 };
            let requested = args.step.unwrap_or(steps);
            let (chosen_step, clamped) = if requested > steps { (steps, true) } else { (requested, false) };
            let raw_board = if chosen_step <= steps {
                // v1 stores states with length steps + 1, where states[i] is the board at step i
                *run
                    .states
                    .get(chosen_step)
                    .expect("trace should have at least one state (initial)")
            } else {
                // Should not happen due to clamp, fallback to last
                *run.states.last().expect("trace should have at least one state (initial)")
            };
            let board_to_show = Board::from_raw(raw_board);
            let next_move = if chosen_step < steps {
                run.moves.get(chosen_step).map(|&b| match b {
                    0 => Move::Up,
                    1 => Move::Down,
                    2 => Move::Left,
                    3 => Move::Right,
                    _ => Move::Up,
                })
            } else { None };
            (
                steps,
                elapsed,
                mps,
                run.meta.max_score,
                run.meta.highest_tile,
                board_to_show,
                chosen_step,
                clamped,
                next_move,
            )
        };

    println!("{} {}", "File:".bold(), format!("{}", args.path.display()).cyan());
    // We don't show start time for v2/v1 split here; omit to keep concise
    println!("{} {:.3}", "Elapsed (s):".bold(), elapsed);
    println!("{} {}", "Steps:".bold(), steps.to_string().magenta());
    println!("{} {:.1}", "Moves/sec:".bold(), mps);
    println!("{} {}", "Max score:".bold(), max_score.to_string().green());
    println!("{} {}", "Highest tile:".bold(), highest_tile.to_string().bright_yellow());

    if clamped {
        println!(
            "{} {} (max is {})",
            "Note:".bold().bright_yellow(),
            format!("requested step {} is out of range; showing highest", args.step.unwrap()),
            steps
        );
    }

    let title = if chosen_step == steps {
        format!("Final Board (step {})", chosen_step)
    } else {
        format!("Board at step {}", chosen_step)
    };
    println!("\n{}\n", title.bold().bright_white());
    print_board_colored(board_to_show);

    // If we're not at the final board, show the agent's move taken from this board
    if let Some(mv) = next_move {
        let (name, arrow) = pretty_move(mv);
        println!("{} {} {}", "Next move:".bold().bright_cyan(), name.bright_white().bold(), arrow.bright_white());
    }

    Ok(())
}

fn pretty_move(m: Move) -> (&'static str, &'static str) {
    match m {
        Move::Up => ("Up", "↑"),
        Move::Down => ("Down", "↓"),
        Move::Left => ("Left", "←"),
        Move::Right => ("Right", "→"),
    }
}

fn print_board_colored(board: Board) {
    // Each cell renders as: space + 7-char content + space = 9 columns
    const CELL_WIDTH: usize = 7;
    let cell_total = CELL_WIDTH + 2; // padding spaces on both sides
    let horiz_len = 4 * cell_total; // 4 cells across
    let horiz = "─".repeat(horiz_len);
    println!("{}{}{}", "┌".bright_black(), horiz.bright_black(), "┐".bright_black());
    for r in 0..4 {
        print!("{}", "│".bright_black());
        for c in 0..4 {
            let idx = r * 4 + c;
            let v = get_tile_val(board, idx as usize) as u64;
            let cell = format_cell(v);
            let styled = style_cell(&cell, v);
            print!(" {} ", styled);
        }
        println!("{}", "│".bright_black());
        if r != 3 {
            println!("{}{}{}", "├".bright_black(), horiz.bright_black(), "┤".bright_black());
        }
    }
    println!("{}{}{}", "└".bright_black(), horiz.bright_black(), "┘".bright_black());
}

fn format_cell(value: u64) -> String {
    if value == 0 {
        return "       ".to_string();
    }
    let s = value.to_string();
    let width = 7usize;
    if s.len() >= width { return s; }
    let pad_total = width - s.len();
    let left = pad_total / 2;
    let right = pad_total - left;
    format!("{}{}{}", " ".repeat(left), s, " ".repeat(right))
}

fn style_cell(cell: &str, value: u64) -> String {
    match value {
        // Empty cells: render as plain spaces (no color/background) to keep them visually blank
        0 => cell.to_string(),
        2 => format!("{}", cell.fg::<Black>().bg::<BrightWhite>().bold()),
        4 => format!("{}", cell.fg::<Black>().bg::<White>().bold()),
        8 => format!("{}", cell.fg::<White>().bg::<Yellow>().bold()),
        16 => format!("{}", cell.fg::<White>().bg::<BrightYellow>().bold()),
        32 => format!("{}", cell.fg::<White>().bg::<Red>().bold()),
        64 => format!("{}", cell.fg::<White>().bg::<BrightRed>().bold()),
        128 => format!("{}", cell.fg::<White>().bg::<Magenta>().bold()),
        256 => format!("{}", cell.fg::<White>().bg::<BrightMagenta>().bold()),
        512 => format!("{}", cell.fg::<White>().bg::<Blue>().bold()),
        1024 => format!("{}", cell.fg::<White>().bg::<BrightBlue>().bold()),
        2048 => format!("{}", cell.fg::<White>().bg::<Cyan>().bold()),
        _ => format!("{}", cell.fg::<White>().bg::<BrightCyan>().bold()),
    }
}
