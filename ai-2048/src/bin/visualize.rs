use ai_2048::engine as GameEngine;
use ai_2048::engine::{get_tile_val, Board, Move};
use ai_2048::{trace, serialization};
use clap::Parser;
use std::fs::File;
use std::io::{self, Write};
use std::path::PathBuf;
use owo_colors::{OwoColorize, colors::*};
use serde::Serialize;

#[derive(Debug, Parser)]
#[command(name = "visualize", about = "Visualize a 2048 run trace (.a2run or .a2run2)")]
struct Args {
    /// Path to a .a2run/.a2run2 file generated by the parallel runner
    path: PathBuf,
    /// Optional step index to display (0..=highest). Defaults to highest.
    #[arg(long, short = 's')]
    step: Option<usize>,
    /// Output the selected board and metadata as JSON
    #[arg(long)]
    json: bool,
    /// When used with --json, write to this file instead of stdout
    #[arg(long, short = 'o')]
    out: Option<PathBuf>,
}

fn main() -> anyhow::Result<()> {
    let args = Args::parse();
    GameEngine::new();
    // Dispatch by extension; default to v1 if unknown
    let ext = args.path.extension().and_then(|s| s.to_str()).unwrap_or("");
    let (steps, elapsed, mps, max_score, highest_tile, board_to_show, chosen_step, clamped, next_move, branches_opt) =
        if ext == "a2run2" {
            let run = serialization::read_postcard_from_path(&args.path)?;
            let steps = run.meta.steps as usize;
            let elapsed = run.meta.elapsed_s as f64;
            let mps = if elapsed > 0.0 { (steps as f64) / elapsed } else { 0.0 };
            // Determine which step to show: default to highest (final), clamp if necessary
            let requested = args.step.unwrap_or(steps);
            let (chosen_step, clamped) = if requested > steps { (steps, true) } else { (requested, false) };
            let raw_board = if chosen_step < steps {
                run.steps
                    .get(chosen_step)
                    .map(|s| s.pre_board)
                    .unwrap_or(run.final_board)
            } else {
                run.final_board
            };
            let board_to_show = Board::from_raw(raw_board);
            let next_move = if chosen_step < steps {
                run.steps.get(chosen_step).map(|s| s.chosen)
            } else { None };
            let branches_opt = if chosen_step < steps {
                run.steps
                    .get(chosen_step)
                    .and_then(|s| s.branches)
            } else { None };
            (
                steps,
                elapsed,
                mps,
                run.meta.max_score,
                run.meta.highest_tile,
                board_to_show,
                chosen_step,
                clamped,
                next_move,
                branches_opt,
            )
        } else {
            let run = trace::parse_run_file(&args.path)?;
            let steps = run.meta.steps as usize;
            let elapsed = run.meta.elapsed_s as f64;
            let mps = if elapsed > 0.0 { (steps as f64) / elapsed } else { 0.0 };
            let requested = args.step.unwrap_or(steps);
            let (chosen_step, clamped) = if requested > steps { (steps, true) } else { (requested, false) };
            let raw_board = if chosen_step <= steps {
                // v1 stores states with length steps + 1, where states[i] is the board at step i
                *run
                    .states
                    .get(chosen_step)
                    .expect("trace should have at least one state (initial)")
            } else {
                // Should not happen due to clamp, fallback to last
                *run.states.last().expect("trace should have at least one state (initial)")
            };
            let board_to_show = Board::from_raw(raw_board);
            let next_move = if chosen_step < steps {
                run.moves.get(chosen_step).map(|&b| match b {
                    0 => Move::Up,
                    1 => Move::Down,
                    2 => Move::Left,
                    3 => Move::Right,
                    _ => Move::Up,
                })
            } else { None };
            (
                steps,
                elapsed,
                mps,
                run.meta.max_score,
                run.meta.highest_tile,
                board_to_show,
                chosen_step,
                clamped,
                next_move,
                None,
            )
        };

    if args.json {
        // Build 4x4 values array (actual tile values)
        let mut board_values: Vec<Vec<u16>> = Vec::with_capacity(4);
        for r in 0..4 {
            let mut row = Vec::with_capacity(4);
            for c in 0..4 {
                row.push(board_to_show.tile_value(r * 4 + c));
            }
            board_values.push(row);
        }

        #[derive(Serialize)]
        struct VizJson<'a> {
            file: &'a str,
            elapsed_s: f64,
            steps: usize,
            moves_per_sec: f64,
            max_score: u64,
            highest_tile: u64,
            chosen_step: usize,
            clamped: bool,
            next_move: Option<&'a str>,
            branches: Option<BranchesOut>,
            board: Vec<Vec<u16>>,
        }

        #[derive(Serialize)]
        struct BranchesOut {
            up: Option<f32>,
            down: Option<f32>,
            left: Option<f32>,
            right: Option<f32>,
        }

        let next_move_name = next_move.map(|m| match m {
            Move::Up => "Up",
            Move::Down => "Down",
            Move::Left => "Left",
            Move::Right => "Right",
        });
        let branches_json = branches_opt.map(|arr| {
            use ai_2048::serialization::BranchV2;
            let to_opt = |b: BranchV2| match b { BranchV2::Legal(v) => Some(v), BranchV2::Illegal => None };
            BranchesOut {
                up: to_opt(arr[0]),
                down: to_opt(arr[1]),
                left: to_opt(arr[2]),
                right: to_opt(arr[3]),
            }
        });

        let payload = VizJson {
            file: &format!("{}", args.path.display()),
            elapsed_s: elapsed,
            steps,
            moves_per_sec: mps,
            max_score,
            highest_tile: highest_tile as u64,
            chosen_step,
            clamped,
            next_move: next_move_name,
            branches: branches_json,
            board: board_values,
        };

        // Write to file if requested, else stdout
        if let Some(out_path) = args.out.as_ref() {
            let mut f = File::create(out_path)?;
            serde_json::to_writer(&mut f, &payload)?;
            f.write_all(b"\n")?; // newline for CLI friendliness
        } else {
            serde_json::to_writer(io::stdout().lock(), &payload)?;
            eprintln!(""); // ensure newline when stdout is piped; use stderr to avoid JSON pollution
        }
    } else {
        println!("{} {}", "File:".bold(), format!("{}", args.path.display()).cyan());
        // We don't show start time for v2/v1 split here; omit to keep concise
        println!("{} {:.3}", "Elapsed (s):".bold(), elapsed);
        println!("{} {}", "Steps:".bold(), steps.to_string().magenta());
        println!("{} {:.1}", "Moves/sec:".bold(), mps);
        println!("{} {}", "Max score:".bold(), max_score.to_string().green());
        println!("{} {}", "Highest tile:".bold(), highest_tile.to_string().bright_yellow());

        if clamped {
            println!(
                "{} {} (max is {})",
                "Note:".bold().bright_yellow(),
                format!("requested step {} is out of range; showing highest", args.step.unwrap()),
                steps
            );
        }

        let title = if chosen_step == steps {
            format!("Final Board (step {})", chosen_step)
        } else {
            format!("Board at step {}", chosen_step)
        };
        println!("\n{}\n", title.bold().bright_white());
        print_board_colored(board_to_show);

        // If we're not at the final board, show the agent's move taken from this board
        if let Some(mv) = next_move {
            let (name, arrow) = pretty_move(mv);
            println!("{} {} {}", "Next move:".bold().bright_cyan(), name.bright_white().bold(), arrow.bright_white());
        }
    }

    Ok(())
}

fn pretty_move(m: Move) -> (&'static str, &'static str) {
    match m {
        Move::Up => ("Up", "↑"),
        Move::Down => ("Down", "↓"),
        Move::Left => ("Left", "←"),
        Move::Right => ("Right", "→"),
    }
}

fn print_board_colored(board: Board) {
    // Each cell renders as: space + 7-char content + space = 9 columns
    const CELL_WIDTH: usize = 7;
    let cell_total = CELL_WIDTH + 2; // padding spaces on both sides
    let horiz_len = 4 * cell_total; // 4 cells across
    let horiz = "─".repeat(horiz_len);
    println!("{}{}{}", "┌".bright_black(), horiz.bright_black(), "┐".bright_black());
    for r in 0..4 {
        print!("{}", "│".bright_black());
        for c in 0..4 {
            let idx = r * 4 + c;
            let v = get_tile_val(board, idx as usize) as u64;
            let cell = format_cell(v);
            let styled = style_cell(&cell, v);
            print!(" {} ", styled);
        }
        println!("{}", "│".bright_black());
        if r != 3 {
            println!("{}{}{}", "├".bright_black(), horiz.bright_black(), "┤".bright_black());
        }
    }
    println!("{}{}{}", "└".bright_black(), horiz.bright_black(), "┘".bright_black());
}

fn format_cell(value: u64) -> String {
    if value == 0 {
        return "       ".to_string();
    }
    let s = value.to_string();
    let width = 7usize;
    if s.len() >= width { return s; }
    let pad_total = width - s.len();
    let left = pad_total / 2;
    let right = pad_total - left;
    format!("{}{}{}", " ".repeat(left), s, " ".repeat(right))
}

fn style_cell(cell: &str, value: u64) -> String {
    match value {
        // Empty cells: render as plain spaces (no color/background) to keep them visually blank
        0 => cell.to_string(),
        2 => format!("{}", cell.fg::<Black>().bg::<BrightWhite>().bold()),
        4 => format!("{}", cell.fg::<Black>().bg::<White>().bold()),
        8 => format!("{}", cell.fg::<White>().bg::<Yellow>().bold()),
        16 => format!("{}", cell.fg::<White>().bg::<BrightYellow>().bold()),
        32 => format!("{}", cell.fg::<White>().bg::<Red>().bold()),
        64 => format!("{}", cell.fg::<White>().bg::<BrightRed>().bold()),
        128 => format!("{}", cell.fg::<White>().bg::<Magenta>().bold()),
        256 => format!("{}", cell.fg::<White>().bg::<BrightMagenta>().bold()),
        512 => format!("{}", cell.fg::<White>().bg::<Blue>().bold()),
        1024 => format!("{}", cell.fg::<White>().bg::<BrightBlue>().bold()),
        2048 => format!("{}", cell.fg::<White>().bg::<Cyan>().bold()),
        _ => format!("{}", cell.fg::<White>().bg::<BrightCyan>().bold()),
    }
}
