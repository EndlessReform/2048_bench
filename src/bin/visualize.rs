use ai_2048::engine as GameEngine;
use ai_2048::engine::{get_tile_val, Board};
use ai_2048::trace;
use clap::Parser;
use std::path::PathBuf;
use owo_colors::{OwoColorize, colors::*};

#[derive(Debug, Parser)]
#[command(name = "visualize", about = "Visualize a 2048 run trace (.a2run)")]
struct Args {
    /// Path to a .a2run file generated by the parallel runner
    path: PathBuf,
}

fn main() -> anyhow::Result<()> {
    let args = Args::parse();
    GameEngine::new();
    let run = trace::parse_run_file(&args.path)?;

    let steps = run.meta.steps as usize;
    let elapsed = run.meta.elapsed_s as f64;
    let mps = if elapsed > 0.0 { (steps as f64) / elapsed } else { 0.0 };
    let final_board_raw = *run
        .states
        .last()
        .expect("trace should have at least one state (initial)");
    let final_board = Board::from_raw(final_board_raw);

    banner();
    println!("{} {}", "File:".bold(), format!("{}", args.path.display()).cyan());
    println!("{} {}", "Engine:".bold(), run.meta.engine_str.clone().unwrap_or_else(|| "<none>".into()).yellow());
    println!("{} {}", "Start (unix s):".bold(), format!("{}", run.meta.start_unix_s).blue());
    println!("{} {:.3}", "Elapsed (s):".bold(), elapsed);
    println!("{} {}", "Steps:".bold(), steps.to_string().magenta());
    println!("{} {:.1}", "Moves/sec:".bold(), mps);
    println!("{} {}", "Max score:".bold(), run.meta.max_score.to_string().green());
    println!("{} {}", "Highest tile:".bold(), run.meta.highest_tile.to_string().bright_yellow());

    println!("\n{}\n", "Final Board".bold().bright_white());
    print_board_colored(final_board);

    Ok(())
}

fn banner() {
    let title = r#"
   ____   ___  _  _   ___  
  / __| / _ \| \| | / _ \ 
 | (__ | (_) | .` || (_) |
  \___| \___/|_|\_| \___/ 
       2 0 4 8   R U N    
"#;
    for line in title.lines() {
        println!("{}", line.bright_yellow());
    }
}

fn print_board_colored(board: Board) {
    let horiz = format!("{}", "─".repeat(37));
    println!("{}{}{}", "┌".bright_black(), horiz.bright_black(), "┐".bright_black());
    for r in 0..4 {
        print!("{}", "│".bright_black());
        for c in 0..4 {
            let idx = r * 4 + c;
            let v = get_tile_val(board, idx as usize) as u64;
            let cell = format_cell(v);
            let styled = style_cell(&cell, v);
            print!(" {} ", styled);
        }
        println!("{}", "│".bright_black());
        if r != 3 {
            println!("{}{}{}", "├".bright_black(), horiz.bright_black(), "┤".bright_black());
        }
    }
    println!("{}{}{}", "└".bright_black(), horiz.bright_black(), "┘".bright_black());
}

fn format_cell(value: u64) -> String {
    if value == 0 {
        return "       ".to_string();
    }
    let s = value.to_string();
    let width = 7usize;
    if s.len() >= width { return s; }
    let pad_total = width - s.len();
    let left = pad_total / 2;
    let right = pad_total - left;
    format!("{}{}{}", " ".repeat(left), s, " ".repeat(right))
}

fn style_cell(cell: &str, value: u64) -> String {
    match value {
        0 => format!("{}", cell.fg::<Black>().bg::<BrightBlack>().bold()),
        2 => format!("{}", cell.fg::<Black>().bg::<BrightWhite>().bold()),
        4 => format!("{}", cell.fg::<Black>().bg::<White>().bold()),
        8 => format!("{}", cell.fg::<White>().bg::<Yellow>().bold()),
        16 => format!("{}", cell.fg::<White>().bg::<BrightYellow>().bold()),
        32 => format!("{}", cell.fg::<White>().bg::<Red>().bold()),
        64 => format!("{}", cell.fg::<White>().bg::<BrightRed>().bold()),
        128 => format!("{}", cell.fg::<White>().bg::<Magenta>().bold()),
        256 => format!("{}", cell.fg::<White>().bg::<BrightMagenta>().bold()),
        512 => format!("{}", cell.fg::<White>().bg::<Blue>().bold()),
        1024 => format!("{}", cell.fg::<White>().bg::<BrightBlue>().bold()),
        2048 => format!("{}", cell.fg::<White>().bg::<Cyan>().bold()),
        _ => format!("{}", cell.fg::<White>().bg::<BrightCyan>().bold()),
    }
}
