use ai_2048::engine as GameEngine;
use ai_2048::engine::{get_tile_val, Board};
use ai_2048::{trace, serialization};
use clap::Parser;
use std::path::PathBuf;
use owo_colors::{OwoColorize, colors::*};

#[derive(Debug, Parser)]
#[command(name = "visualize", about = "Visualize a 2048 run trace (.a2run or .a2run2)")]
struct Args {
    /// Path to a .a2run/.a2run2 file generated by the parallel runner
    path: PathBuf,
}

fn main() -> anyhow::Result<()> {
    let args = Args::parse();
    GameEngine::new();
    // Dispatch by extension; default to v1 if unknown
    let ext = args.path.extension().and_then(|s| s.to_str()).unwrap_or("");
    let (steps, elapsed, mps, engine_str, max_score, highest_tile, final_board) = if ext == "a2run2" {
        let run = serialization::read_postcard_from_path(&args.path)?;
        let steps = run.meta.steps as usize;
        let elapsed = run.meta.elapsed_s as f64;
        let mps = if elapsed > 0.0 { (steps as f64) / elapsed } else { 0.0 };
        let final_board = Board::from_raw(run.final_board);
        (
            steps,
            elapsed,
            mps,
            run.meta.engine_str.clone(),
            run.meta.max_score,
            run.meta.highest_tile,
            final_board,
        )
    } else {
        let run = trace::parse_run_file(&args.path)?;
        let steps = run.meta.steps as usize;
        let elapsed = run.meta.elapsed_s as f64;
        let mps = if elapsed > 0.0 { (steps as f64) / elapsed } else { 0.0 };
        let final_board_raw = *run
            .states
            .last()
            .expect("trace should have at least one state (initial)");
        let final_board = Board::from_raw(final_board_raw);
        (
            steps,
            elapsed,
            mps,
            run.meta.engine_str.clone(),
            run.meta.max_score,
            run.meta.highest_tile,
            final_board,
        )
    };

    banner();
    println!("{} {}", "File:".bold(), format!("{}", args.path.display()).cyan());
    // Engine is optional
    println!("{} {}", "Engine:".bold(), engine_str.clone().unwrap_or_else(|| "<none>".into()).yellow());
    // We don't show start time for v2/v1 split here; omit to keep concise
    println!("{} {:.3}", "Elapsed (s):".bold(), elapsed);
    println!("{} {}", "Steps:".bold(), steps.to_string().magenta());
    println!("{} {:.1}", "Moves/sec:".bold(), mps);
    println!("{} {}", "Max score:".bold(), max_score.to_string().green());
    println!("{} {}", "Highest tile:".bold(), highest_tile.to_string().bright_yellow());

    println!("\n{}\n", "Final Board".bold().bright_white());
    print_board_colored(final_board);

    Ok(())
}

fn banner() {
    let title = r#"
   ____   ___  _  _   ___  
  / __| / _ \| \| | / _ \ 
 | (__ | (_) | .` || (_) |
  \___| \___/|_|\_| \___/ 
       2 0 4 8   R U N    
"#;
    for line in title.lines() {
        println!("{}", line.bright_yellow());
    }
}

fn print_board_colored(board: Board) {
    let horiz = "─".repeat(37);
    println!("{}{}{}", "┌".bright_black(), horiz.bright_black(), "┐".bright_black());
    for r in 0..4 {
        print!("{}", "│".bright_black());
        for c in 0..4 {
            let idx = r * 4 + c;
            let v = get_tile_val(board, idx as usize) as u64;
            let cell = format_cell(v);
            let styled = style_cell(&cell, v);
            print!(" {} ", styled);
        }
        println!("{}", "│".bright_black());
        if r != 3 {
            println!("{}{}{}", "├".bright_black(), horiz.bright_black(), "┤".bright_black());
        }
    }
    println!("{}{}{}", "└".bright_black(), horiz.bright_black(), "┘".bright_black());
}

fn format_cell(value: u64) -> String {
    if value == 0 {
        return "       ".to_string();
    }
    let s = value.to_string();
    let width = 7usize;
    if s.len() >= width { return s; }
    let pad_total = width - s.len();
    let left = pad_total / 2;
    let right = pad_total - left;
    format!("{}{}{}", " ".repeat(left), s, " ".repeat(right))
}

fn style_cell(cell: &str, value: u64) -> String {
    match value {
        0 => format!("{}", cell.fg::<Black>().bg::<BrightBlack>().bold()),
        2 => format!("{}", cell.fg::<Black>().bg::<BrightWhite>().bold()),
        4 => format!("{}", cell.fg::<Black>().bg::<White>().bold()),
        8 => format!("{}", cell.fg::<White>().bg::<Yellow>().bold()),
        16 => format!("{}", cell.fg::<White>().bg::<BrightYellow>().bold()),
        32 => format!("{}", cell.fg::<White>().bg::<Red>().bold()),
        64 => format!("{}", cell.fg::<White>().bg::<BrightRed>().bold()),
        128 => format!("{}", cell.fg::<White>().bg::<Magenta>().bold()),
        256 => format!("{}", cell.fg::<White>().bg::<BrightMagenta>().bold()),
        512 => format!("{}", cell.fg::<White>().bg::<Blue>().bold()),
        1024 => format!("{}", cell.fg::<White>().bg::<BrightBlue>().bold()),
        2048 => format!("{}", cell.fg::<White>().bg::<Cyan>().bold()),
        _ => format!("{}", cell.fg::<White>().bg::<BrightCyan>().bold()),
    }
}
